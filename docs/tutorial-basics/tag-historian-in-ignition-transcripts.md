---
sidebar_position: 9
---

# Tag Historian In Ignition - Video Transcripts

This page contains transcripts from the tag-historian-in-ignition video course.

## Overview

These transcripts are automatically generated from the [tag-historian-in-ignition Course](https://inductiveuniversity.com/courses/ignition/tag-historian-in-ignition/8.1) on Inductive University.

:::info
Generated on: 6/9/2025, 2:29:21 PM
Source URL: https://inductiveuniversity.com/courses/ignition/tag-historian-in-ignition/8.1
:::

## Video Transcripts

### 1. Configuring Tag History Video at Inductive University

:::tip Video Link
Watch the video: [Configuring Tag History Video at Inductive University](https://inductiveuniversity.com/videos/configuring-tag-history/8.1)
:::

<details>
<summary>View Transcript (8 paragraphs)</summary>

**[00:00]** [00:00]
                                    In this video, we are going to take a look at how we can configure tag history. Tag history is Ignition's built-in method of recording tag values to a database, and then later pulling them back out so that we can view them within our projects, all without having any knowledge of how a database works, or how to use the SQL Query language. All we need is a valid database connection. To configure tag history, we need to open up our designer, and find a tag. Tag history is actually configured on the tag itself. So when we find our tag, we'll go ahead and edit that tag. Here in the tags properties, we're going to scroll all the way down to the bottom of this list. We're going to find the history section, and there's going to be a single property there called history enabled. To turn on tag history, we need to set that to true.

**[01:05]** [01:05]
                                    Now, when you do that, you'll notice the scroll bar on the right jumped a little bit. And that's because there are now additional properties under this history section when history enabled is set to true. So I'm going to scroll down so we can see the rest of those. Now to finish configuring tag history, the only other thing that we need to do here is specify a storage provider. The storage provider is the database where you want to store your tag history data. I'm going to go ahead and specify my database that I already have set up and connected. Now like I said, this is actually all that we need to do. We can leave all these other properties at their default settings, hit okay, and we are now storing history on this particular tag. You'll notice that the tag has a symbol next to it of a little clock that signifies that historical records are being saved for this particular tag. Now that historical values are being stored for this tag, we can pull that data back out of our database using either a chart or a table, or any of the other components that we might have in either Vision or Perspective.

**[02:14]** [02:14]
                                    You can find out more information about how to pull the data out of the database, by checking out some of our other videos, such as tag history binding in either Vision or Perspective, or our various charting videos. Now while the tag history system can work just fine at default settings, you may recall that there were a few other properties that we can configure on the tag when we set up tag history. Let's take a look at those now. There are three properties in particular that I want to talk about. The first property is Deadband style. Now by default, the Deadband style is set to auto, but there are actually two main settings for Deadband style. Either analog, or discreet. To put it simply, the Deadband style of discreet is used for tags that have discreet values, such as a status.

**[03:09]** [03:09]
                                    When the values for this particular tag are recorded with a discreet Deadband style, we can assume that the values jump from one to the next. So if the values that get recorded go from zero to then two, the jump is immediate. The analog Deadband style works a little bit differently, and is typically used for tags that do not have discrete values. Take, for example, a temperature. While a temperature can have values of say 60, 61, and 62, there are many values in between those values, such as 60.5 or 61.7. So when the tag history system records this tag with a Deadband style of analog, the tag history system assumes that the value is flowing from one value to the next. Meaning if I had recorded a value of 60, and then later a value of 62, I can assume that at some point, the value flowed over 60.5, 61, 61.5, and all of the values in between.

**[04:11]** [04:11]
                                    Again, very different from discreet, which would go from zero directly to two without ever being one in between. The default setting here of auto simply determines for you based on the tag data type and its values. The next property that I want to talk about is the Deadband mode. The dead band mode determines how to apply the Deadband to the value of the tag to determine when it's changed. By default, it's set to absolute, and the historical Deadband property will directly be applied to the value of the tag. However, it is possible to change the Deadband mode to percent, at which point the historical Deadband will be applied as a percentage of the tag's value. The last property that I want to take a look at here is the sample mode property. The sample mode property determines how often we are going to be sampling this tag to determine if we are going to store it in the database.

**[05:07]** [05:07]
                                    By default, the sample mode is set to On Change, which means that we are going to check the tag value every time it changes to determine whether we should store it within the database or not. If you're pulling your tag at a very high rate, that may be a little bit quick though. So we do have some other options available to you. Periodic allows you to specify a rate at which you want this to be sampled. Say, you can set your periodic rate to 10 seconds. You would be able to set that up there. The other option is Tag Group, which specifies a rate based on a tag group that you have previously set up. These tag groups are also used to specify a rate at which tags are sampled. And you can use those here within your tag history setup as well. Tag Group is similar to the periodic option, but Tag Group allows you to take advantage of some of the tag group's features, such as driven or leased tagged groups.

**[06:08]** [06:08]
                                    The last thing that I want to go over is turning on tag history on a UDT. Configuring history on a UDT works very similar to how you would configure history on a standard tag. The big difference is that you configure the tag history in the UDT definition, rather than on the tag itself. I already have a UDT setup, and some instances of this UDT created here. I've got some motors, and you'll notice none of them have history being stored on them. And if I go over to my UDT definitions tab, we can see my motor definition there. I'll go ahead and edit the definition, and select one of my tags inside, say this amps tag. And just like before, I'm going to scroll down to the bottom of its property list.

**[06:59]** [06:59]
                                    I'm going to find that history enabled property, and set that to true. Again, I'll scroll down further, and find that storage provider setting, and choose a storage provider where my data will be stored. I can then configure any of the other properties that I want, and when I'm done, I can hit Okay. This tag history setting will now be applied to this UDT. So all instances of the UDT will now be storing history on that Amps tag.

</details>

---

### 2. Data Partitioning and Pruning Video at Inductive University

:::tip Video Link
Watch the video: [Data Partitioning and Pruning Video at Inductive University](https://inductiveuniversity.com/videos/data-partitioning-and-pruning/8.1)
:::

<details>
<summary>View Transcript (4 paragraphs)</summary>

**[00:00]** [00:00]
                                    In this video, we are going to talk about the data partitioning and pruning feature of the Tag Historian. By default, the Tag Historian system will partition data out into multiple tables. These partitions help keep the individual table size fairly small as a single table with a lot of records is usually pretty slow to query. So, by splitting up the data into these partitions we can keep most queries to the Tag Historian system pretty quick. The Tag Historian system also has the ability to turn on data pruning, where it will remove older records. These features can help you automatically manage the data in your tagged history system. And are configured in the configure section in the tag history page.

**[01:01]** [01:01]
                                    Here we can see my historical tag provider and to manage these features we simply need to edit the historical tag provider by clicking on the edit button on the right. I'm going to scroll down a little bit here and we can see this first section we have here is data partitioning. Like I said earlier, data partitioning is turned on by default. And it is set up to partition once a month. I'm going to briefly pull in my management studio so we could take a look at the tables in my database. We can see here I've got the tag history tables and there are two tables for data. One for September and one for October. If I were to store data in the month of November, then the system would have automatically created a third data table that ended in 11. Let's go back to our historical tag provider settings. Where I can see that not only can I change how often the Tag Historian system partitions my data, but I can also decide to turn partitioning off entirely.

**[02:16]** [02:16]
                                    I can also decide to take my partitioning one step further and use preprocessed partitions. When pre-process partitions are enabled, the Tag Historian system will actually create a second partition every time it makes one. This second partition is a summary of the data in the first partition. The data is summarized based on the window size that you set in this property down here. This means that the data is shrunk even further and the table made even smaller. This can help when querying data over a large period of time. Oftentimes when querying a large of data you don't need it to be quite as granular as your standard partition. Because the pre-process partition is a summary of that data and there is less of it, it can be queried and returned much quicker than if we were only querying the standard partitions.

**[03:19]** [03:19]
                                    Finally, you can also enable data pruning on your Tag Historian system. The data pruning system will automatically remove old data from the tag history system out of your database. The data pruning system works by removing older partitions not individual records of data. This means that the data pruning system will wait until an entire partitions worth of data is older than the prune age that you have set up here. Once the entire partition is past that prune age, then it will remove the entire partition as a whole rather than removing individual records from it. You can adjust the prune age here so that your data is kept for as long as you need it.

</details>

---

### 3. Displaying Tag History Video at Inductive University

:::tip Video Link
Watch the video: [Displaying Tag History Video at Inductive University](https://inductiveuniversity.com/videos/displaying-tag-history/8.1)
:::

<details>
<summary>View Transcript (7 paragraphs)</summary>

**[00:00]** [00:00]
                                    The Tag Historian system logs data to a database of your choice. Ignition then offers features to be able to read this data back for visualization purposes. Using either perspective or vision modules Tag Historian data can be displayed on tables, charts among other components using tag history bindings as well as built-in functionality within some components. In this lesson, we will cover tag history bindings and some of the built-in features some visualization components have to display tag history data. We are currently in our designer. I want to visualize my historical data in a chart. I am currently looking at a perspective view named myview. From my perspective component palette. I will grab a power chart and drag it onto my view. I can then put the designer in preview mode and press the little tag button on the upper left hand quarter of my power chart. Doing so we'll expose a tag browser that will allow me to browse through all of my historical tags.

**[01:08]** [01:08]
                                    First, I have to choose which database I want to get my data from. My database is called training. I then have to select which gateway and from which realtime tag provider my tags are coming from. Finally, I can browse through and select which tags I want to trend. I can either select one tag or I can press and hold the Control key to select multiple tags. Once I'm happy with my selection, I can press the add selected tags button and I will begin to see my tag data trended on my power chart. I will hide my tag browser by pressing this button here and if I click on the little calendar icon on top of my chart, I can select the amount of time I want to see data for or I can give it a start and end date as well in historical mode. Down on the bottom, I get a small table which shows me which tags I am currently trending data for. I can choose to delete this tag from my trend or I can choose to edit this configuration by pressing the little pencil next to it.

**[02:06]** [02:06]
                                    Here, I can change the name of my line, give it its own plot or axis, changes its color, aggregation mode among other things. So with just a few clicks, I can select which tags I want the trend and the power chart will query the database for historical data and begin trending it. That is one example of a components built in features to display historical data. I can also grab something like say a table from my perspective component palette. This components data is driven by a state data property which we can see here on the property editor on the right. If I want it to display historical data on this table, I would have to configure a tag history binding on this table's data property. To do that, I will click on the binding icon next to the data property and select the tag history binding type on my binding editing window. This will bring on my tag history bindings configuration which allows us to configure how I want this binding to query for historical data.

**[03:08]** [03:08]
                                    First, we see the return format. Wide format means the query will return a column for every tag we are querying for along with a timestamp column. Tall means that the query result will have columns for value, quality, timestamp and tag path for each tag we query and each row in my query result is a new tag value at a specific time. The calculations option just allows you to perform calculations on the return data before it goes into our table. Query mode allows me to specify how many rows I want my history query to return. With pointcount, I can tell the system to only ever return say 100 points or a single point if I want it to. With periodic, I can tell the system to return a record for every period of time within my query specify time range. Asstored query mode will return the historical data as it was stored in the database.

**[04:05]** [04:05]
                                    My time range can either be real time where I can specify how recent I want my historical data to be or I can do historical mode where I can specify a start and end date for my historical queries time range. I can also define my binding to pull at a specific rate if I wanted to. Now I can select which tasks I want to query history for. To do that, I can click on this little tie icon and drill down and find all the tags I have tag history configured for. In my case, I will select Ramp0 and press okay. Once my tag is added, I can give it an alias or configure an aggregation mode to be applied to my query result. Say I only want to see my Ramp0 tags average value, I can do that. Before I finished my configuration though, I want to talk about my bindings options here above my preview. First I can choose to enable, disabled my binding and I can choose to opt out of any warning or error overlays associated with this binding itself.

**[05:06]** [05:06]
                                    I can also tell the binding to ignore any bad quality data logged by the historian and I can tell the binding to prevent any interpolation of my historical data. You will also notice the binding preview down at the bottom has updated to show me a preview of the data my query will return. I will now click OK to exit my configuration and I will see my table was showing a single value for the past one hour representing my Ramp0 tag average value. I also have to add two new column objects to my table component. To do that, I head over to its columns property and click the little blue plus sign to add a column object. I have two columns on my table so I will add a second column object like so. I will then set my zero with columns field property to t_stamp and set its dateFormat to something a bit more suitable. Now I can set my first column objects field property to Ramp0 and I am finished with my configuration.

**[06:08]** [06:08]
                                    This is one example where we can use tag history bindings to retrieve information from our Historian.

</details>

---

### 4. Tag History Splitter Video at Inductive University

:::tip Video Link
Watch the video: [Tag History Splitter Video at Inductive University](https://inductiveuniversity.com/videos/tag-history-splitter/8.1)
:::

<details>
<summary>View Transcript (6 paragraphs)</summary>

**[00:00]** [00:00]
                                    In this lesson, we'll talk about `</v>` the Tag History Splitter Provider. Now in our earlier videos that talk about the Tag Historian, you already saw how to configure history on a tag. So I can edit a tag, I can go down to it's history settings, I can enable history. And then from here, we can specify which of our historical providers we want to store the data at. Although we do run into a little bit of a problem if you wanted to store into multiple at the same time. So this is actually a common scenario you see, with some of our architectures, specifically the Hub-and-Spoke architecture. So in this architecture here, just as a refresher, you do have spokes, which are sort of these smaller installations. And then you do have this centralized hub here. The idea being that the spokes push data towards the hub. Now in this scenario here, say, we look at this one little spoke over here, say it has its own PLCs, its own ignition installation, but it has it's own clients too, or Perspecitve sessions maybe even right, and it has his own database.

**[01:06]** [01:06]
                                    So the idea being you can look at trends and history from the PLCs that were collected over here on the spoke. But you also want to push that data up to the central or the hub database here. So really you're trying to store into two different locations. Now by far, the easiest way to do this is to use what's called a Tag History Splitter Provider. So if I were to, I'm going to close this here and I'm going to switch over to a web browser here, and I'm looking at my gateway and not just any gateway I am actually looking at the spoke gateway in this scenario. I have a couple of database connections here. I have the, Sample SQLite Database that comes with Quickstart project, but I'm going to ignore that for this video. And I'm going to focus on DB1 and DB2. Specifically DB1 is a connection that leads to the spoke's database. And DB2 is a connection that leads to the hub's database. Now I have these database connections already configured, but let's take a look at the tag history provider.

**[02:04]** [02:04]
                                    So I'm going to scroll on down here and under Tags, I'm going to click on History and we do see that we have the Datasource History Provider. So these are the providers that are created automatically when you have a database connection, but we actually want a new provider. So I'm going to click on Create new Historical Tag Provider here. And I'm going to select the Tag History Splitter. So I'll click Next. Let's give this a name. What this provider does is instead of storing records itself, it sends the records to two other providers and then those two other providers handle the storage. So this case here, I can set the first connection to DB1 and the second connection to DB2. And that's really all I need to do. So I'll scroll down here and click the Create New Historical Tag Provider button. Okay, we now have our splitter provider, which means I can switch back over to my designer. I can open up the tag editor again. So I'll double click on Ramp0 and we'll look at those history settings again.

**[03:02]** [03:02]
                                    You may have to refresh this, if you left your Tag Editor open the whole time. But under the Storage Provider, we now have Splitter as an option. Right. So this point forward, once I click OK here, as value changes on this tag are recorded, it's going to be sent to the splitter. And then the splitter is going to send those value changes to DB1 and the DB2 providers. And that's really all you have to do. Now something gets kind of neat about this. If I were to look at that architecture, that diagram one more time here. It's pretty common that folks want the spokes here to have a sort of light database. They don't want to keep records necessarily for long periods of time. They want to keep some local history but they don't want to record everything forever. That's what the hub's for. They want everything forever to go to the hub. So the way you set that up, it's actually really easy. I'm going to head back to my gateway here, and there's really two things you need to do. First back on the splitter settings, I'll go ahead and edit the splitter provider and you can kind of see from the descriptions here, but the way the splitter really works is it does store to both of these two different connections equally.

**[04:11]** [04:11]
                                    But when we're trying to query from this provider, so say in the spoke's project, say we have a chart on a window or a view somewhere, and the chart is running a query against the splitter provider looking for data from that Ramp0 tag. By default, it would actually request the records from just the first connection in this case. So are, in this case DB1 or the spoke's own database. But it does tell you that you can actually start messing around with these querying properties down here. So I could opt into this Limit First Connection Query, which basically means, okay, any requests or queries against this provider that look for data outside of the time specified here. So outside of one month, will actually go against the second connection. So what that means for us is that we can actually say, alright, only look for, the last couple months of records in the spoke's database, but anything that goes beyond that, go ahead and reach out to the hub and collect the records from there.

**[05:05]** [05:05]
                                    And then put those on the screen. Now this will go ahead and basically split up how we do the querying. But if you really wanted to keep that database on the spoke light, there's one more thing you'd need to do. So I'll save this change here, but you'd actually need to go and take a look at the history provider for the spoke, right. So if I edit DB1 here, the splitter is handing off to the DB1 provider here, which means any sort of settings on this provider will still be respected. So I could scroll on down here and I can go down to Data Pruning. And I could basically say, go ahead and delete anything that falls outside of a month or two months or however you want to spin that. So really you can have this be as restrictive as you need to be, but then just don't turn on pruning on the DB2 connection. That way you'll keep everything forever. But that about wraps it up for the Task History Splitter, honestly, it's a very simplistic provider to use. You just create it and point it to two different tag history providers and it'll start to store against both of them.

</details>

---

### 5. Historian Simulator Video at Inductive University

:::tip Video Link
Watch the video: [Historian Simulator Video at Inductive University](https://inductiveuniversity.com/videos/historian-simulator/8.1)
:::

<details>
<summary>View Transcript (6 paragraphs)</summary>

**[00:00]** [00:00]
                                    In this lesson we'll take a look at the historian simulator which is a simulator provider that's built into the tag historian module. This simulator is unique in that you don't need any sort of tags or external connections to retrieve some data from it. You can simply provide it a path and it will return a result set for you. To use it we first need to create an instance of the provider, so on our gateway here under the config section, I'm going to scroll on down and under tags, I'll click on history. Now I do have some history providers already configured but we'll ignore those 'cause I'm not going to use them in this video, instead, I'm going to click on the create new historical tag provider link. And from the list here, let's go ahead and click on simulator, I'll click next and we can give this a name here. So how about just simulator, I'll then go ahead and click the create new historical tag provider and that's all we have to do on the gateway side, we're actually ready to start using this new provider.

**[01:05]** [01:05]
                                    So I'll switch over to my designer here and really you can use this provider anywhere in ignition that can request tag history queries or call them. So tag history bindings, for example, in Vision or Perspective, I'm not going to show you all of the different places since there's quite a bit, instead I'm just going to focus on the reporting module here, just because it gives me a lot of room to show off the feature. Now I have a report here, I have a blank time series charts, It doesn't have any data, so let's go ahead and populate this with some data. I'll switch to the data tab here and I'll hit the little plus button to add a new tag historian query. And here we do see that we have the simulator and we have a whole bunch of built in historical tags that we can use. We'll talk about the notation in the path here in just a moment, but I think to start with I'll go ahead and I'll grab this ramp tag, drag it over and then I'll play with some of the settings here, I'll go ahead and switch us over to real time, we'll say how about maybe just five minutes and I'll switch the aggregation mode to time weighted average. And I should add the reason I'm making changes to the history settings here is because it makes the resulting data set a little bit easier to talk about, so these aren't like mandatory for using the provider, you can set these to whatever you prefer.

**[02:13]** [02:13]
                                    Now I'll switch over to design here and on my charts, let's go ahead and we'll add our tag history data source as the data key and then I'll grab that little ramp key there. We'll add that as a pen and now we can switch over to preview and We now have some data, now I can see it's doing this repeating ramping behavior and kind of just starts over every so often, it gets close to about a hundred or so. Now if we head back to the data tab here and we look at the path here notice that it does have a couple of pieces of information in the path that kind of stand out really. First of all, everything's delimited by an underscore, next you'll notice some commonalities with our data, our trend was ramping and we see the word ramp here. It peaked around 100 and we see 100 here. Now, if you look at the available historical tags tree here you'll notice one of the entries states function, period, amplitude and resolution. This one tag is an example that points out the various arguments that go into the tag path. So depending on what values you provide these arguments in the path here, the return results set will be modified.

**[03:18]** [03:18]
                                    So to compare it to our tag, function determines what function to use. In our case we're using ramp period is the duration of the function from start to finish, so each peak in our ramp function will be spread across the amount of time specified by this argument. Amplitude is the peak for the function to use, resolution determines how many raw data points will make up the underlying results, we'll look closer at this one later on. Now if I make changes to my path here, say I changed the period to five M or five minutes, and we'll change the peak to 250. I'll switch back to preview and you can see we only get one peak over this five minute period of time and it does peak at 250. They'll also notice that it doesn't start at zero, rather the start here is midway up the peak, to help simulate real world usage, the results don't just initialize with zero here. Instead, the resulting data set acts as if the tag has been changing prior to the requested time range.

**[04:12]** [04:12]
                                    If we were to change the range on our tag history data source, we'd see the earlier points in the day where this fictitious data would have peaked over and over again. Anyways, our path asks for a single peak add 250 over five minute period and you can see that's how the data is being presented. Now let's talk about the final argument in the path, which was resolution. If we look at the XML preview here we see the data starts at row zero. If I scroll to the bottom, we see the final row ends at row 99, so this trend has made up of 100 data points that 100 is actually due to the reporting module. Let's switch back to the data tab, the preview limit here on the right, which has nothing to do with the simulator, this is a setting provided by the reporting module. It's set to 100, so it's restricting the number of rows this query can return. I'll uncheck this just to remove the limit, I'll switch back to preview and we can see we are now at row 999, so 1,000 rows. Now this 1000 row is due to the history settings we have, so if I go back to the data tab, we're using a fixed sample size, so this query is aggregating all of the raw data that the history system has access to for this tag here and bringing it to 1000 points.

**[05:20]** [05:20]
                                    Now, if I were to change this to on change instead, our results that is going to be driven purely by the raw data. Here's where the resolution argument comes into play because this ultimately determines how often a raw data point is generated within the simulator. Right now it's set to one second, so our simulated path will request a raw data point every one second over the specified range, which is five minutes. If we switched back to preview and look at the XML again we see 300 data points, which makes sense in a five minute period, there are 300 seconds. If we go back to data, we can change this from every one second to 200 ms or milliseconds. So if you wanted the raw data to be more granular you can modify the resolution. Back to preview, we can see considerably more rows and we ended up at 1499 or 1500 rows. Now the main benefit of the resolution argument here is that you can get a better idea of how the various aggregation modes and settings will be applied to the results of the query, but that about wraps up the simulator here. As you can see, it's pretty straightforward to use. There is more documentation in the user manual. You can go ahead just search for the historian simulator page, if you wanted to see the full list of all of the functions.

</details>

---

### 6. DB Table Historian Video at Inductive University

:::tip Video Link
Watch the video: [DB Table Historian Video at Inductive University](https://inductiveuniversity.com/videos/db-table-historian/8.1)
:::

<details>
<summary>View Transcript (1 paragraphs)</summary>

**[00:00]** [00:00]
                                    In this lesson, we'll take a look at the DB Table Historian Provider, which is a unique provider that takes the content of tables created outside of the Historian system and exposes their contents to things like Tag History queries. Now, to begin with, we first need a database table. I have this DB Database Connection Provider here. And inside of it, I have not one, but two tables. So, I created two tables, and using MySQL Workbench here, create a table_a and table_b. So, table_a has a couple of rows, and table_b, also has a couple of rows. Both tables also have at least one DATETIME column. If you're curious how I configured these, here are the settings I use. You can pause the video if you wanted to look a little bit closer at them. But that's not super important. What's important is that, they do have some rows, and we're going to go ahead and take the contents of both tables and we're going to expose them to different bindings and components within our project. So, we have a Database Connection with some tables. To use this provider, first, we need to create an instance of the provider. So, on my gateway here, under Config, we can scroll on down, and under Tags, I can go to History. And, let's go ahead and create an instance of this provider. So, I'll click the Create New Historical Tag Provider link. And from the list of options, we'll select the DB Table Historian, or in this case, the first one in the list. I'll click Next. And let's give this provider a name here, so, how about just "DB_TH". Now, aside from the name here, the only other property you really need to worry about, is this Data source property. So, you need to effectively tell this provider which of your database connections it should be looking at. Now, my case it is in fact, the DB database I want to look at. So, I'll click the Create New Historical Tag Provider button. Okay, we're actually done configuring our provider. Now, we get to try to use it. So, let's go ahead and switch over to our Designer. Now, to start with, I think I'll focus on perspective, so, you can see I'm looking at a view here, and I have a PowerChart selected. Now, what we can do with this new provider is, we can, I'm going to put my Designer to Preview Mode here. And I'll go ahead and start browsing for Tags here on the PowerChart. If you don't see your Historian on there, you can always go ahead and refresh. But looks like I have mine here, anyways. We can go into DB_TH, we can see our two tables. I can go to table_a, and I do want to show the value, I want to trend the value. So, I'll go ahead and select value, I'll click the Add Selected Tags button. And there's our trend. And it was that easy. Although, I did cheat. There is one little thing I did that I should talk about. And that would be the t_stamp column here. The DB Table Historian Provider has limited ability to interpret the meaning behind any given table. To give this feature better interplay with transaction groups, The provider will recognize any column named t_stamp, as the column it should use as the DATETIME for each row. Which is why that first example from table_a worked right away. However, your tables likely won't always have a t_stamp columns. So, let's look at what we can do in those scenarios. Let's go ahead and get rid of this pen here. And, let's take a look at table_b. Now, if you recall table_b actually had a couple of DATETIME columns. So, I had one called time, and then I had more_time. Time is showing 13:00 or 1:00 p.m. times, and more_time is showing 15:00 or three o'clock. So, if we try to add value from table_b here, we actually get a whole lot of nothing. You'll get some errors in the console, but we do see that the PowerChart here does have a new pen. So, we're actually getting an error just because in this case, it doesn't really know which of those timestamp columns to use. Now, let's take a closer look here. Now, this part's kind of specific to the PowerChart here, but really, the key part here is being familiar with how the various features that Ignition that can query Tag History, configure the path to the tag in the History system. So, in this case, the PowerChart will list its pens on the Pen's tab here. If we scroll down here, we do have a little path that leads to the values that are coming from my table. Now, to make this a little bit easier to talk about, I'm actually just going to copy this out, and I'm going to move that text over to something that's a little bit easier for you to see. Now, again, if you've seen these historical paths with the Tag Historian Module, you may be familiar with some of the ideas or the notation here. But in our specific case here, the : and /, sort of delimit different units or different components of this path here. So, if I were to try to make this a little bit more readable. So, the History Provider name is, DB_TH, the table in that provider is, table_b, and then the column from that table that we want to use on this pen here is the column, "value". There's actually more stuff we can add here, it just doesn't add a timestamp by default, but you can actually specify which column is the TIMESTAMP or the DATETIME. So, in this case, I'm going to add a new line, we'll put a :/ down, and if you check the User Manual on the DB Table Historian Provider page. You can search for it, it's also alongside all of the other Tag Historian Provider stuff. There's actually a timestamp component. And, this allows you to just type in the name of the column that's going to be the timestamp for this particular point of data. So, I do have a time column, and we did say time was the 1:00 p.m. times. So, let's try to use that. I'll go ahead and I'll get rid of all those new lines here, and I'll select everything, we'll copy that out, and I will replace that down below. We could have just typed it down here, but easier for me to just copy-paste. I'll click Done, and look at that, we do have a trend that's actually showing again. If I were to try to look at the timestamp here, we can see that it's showing about one o'clock, I was off a little bit with my click there. We can also, of course, go back to those Pen Settings. And we could actually change the end of this little path here, instead of specifying time, that we can change it to more_time. Which should give us the 3:00 p.m. times. And look at that. Great, so really, you just need to be aware that the additional components for these paths exist. Now, let's also just take a look at Vision, just to give you a different interface to kind of show you the same sort of routine. Over here, in Vision, I do have a Power table. If I select it, and head down the Property Editor, I can take a look at the Data property, which we know is where the Power Table gets all the content, or data that's supposed to show inside of it. Let's configure a binding, we'll do a Tag History Binding, and I'll go ahead and refresh this from an earlier take here. But you can see, that we do have our table being basically the same kind of interface we saw earlier with the Power table. I'll go ahead and try to add value over here, but I'll go ahead and just double click, and I will paste in that path we just copy-pasted from earlier, where we're pointing at time, and play around with the real time settings. We'll set it for four hours, I suppose. And there we go. We've got our two, 1:00 p.m. times here. All right, that's going to about wrap it up for this video. Again, I'd highly advise you take a look at the User Manual page just because it does have more information on the various components, but really just modifying that Historical Tag Path is the key piece of information you need to be aware of when using this provider.

</details>

---

## Additional Resources

- [Inductive University](https://inductiveuniversity.com/)
- [Ignition Documentation](https://docs.inductiveautomation.com/)
- [Ignition Downloads](https://inductiveautomation.com/downloads/)
